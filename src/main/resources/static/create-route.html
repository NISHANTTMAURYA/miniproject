<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Route Management</title>
  <style>
    #map {
        height: 400px;
        width: 100%;
        margin: 20px 0;
        border: 1px solid #ccc;
        border-radius: 4px;
    }
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f0f0f0;
    }
    h1, h2 {
        color: #333;
    }
    form {
        background-color: #fff;
        padding: 20px;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
    }
    label {
        display: block;
        margin-bottom: 5px;
    }
    input, select {
        width: 100%;
        padding: 8px;
        margin-bottom: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        box-sizing: border-box;
    }
    button {
        background-color: #4CAF50;
        color: white;
        padding: 10px 15px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }
    button:hover {
        background-color: #45a049;
    }
    table {
        width: 100%;
        border-collapse: collapse;
        background-color: #fff;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    th, td {
        text-align: left;
        padding: 12px;
        border-bottom: 1px solid #ddd;
    }
    th {
        background-color: #f2f2f2;
        font-weight: bold;
    }
    .edit-btn, .save-btn, .cancel-btn {
        padding: 5px 10px;
        margin-right: 5px;
    }
    .edit-btn {
        background-color: #008CBA;
    }
    .save-btn {
        background-color: #4CAF50;
    }
    .cancel-btn {
        background-color: #f44336;
    }
    #successMessage {
        color: green;
        margin-bottom: 10px;
    }
    #errorMessage {
        color: red;
        margin-bottom: 10px;
    }
    #map {
        height: 400px;
        width: 100%;
        margin: 20px 0;
        border: 1px solid #ccc;
        border-radius: 4px;
    }
    .custom-marker {
        background: none;
        border: none;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .start-marker {
        color: #4CAF50;
    }

    .end-marker {
        color: #f44336;
    }

    .marker-popup, .route-popup {
        padding: 5px;
        font-family: Arial, sans-serif;
    }

    .leaflet-popup-content-wrapper {
        border-radius: 8px;
        box-shadow: 0 3px 14px rgba(0,0,0,0.4);
    }

    /* Add Font Awesome for markers */
    @import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css');

    .fa-location-dot {
        font-size: 24px;
        filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.5));
    }

    .start-marker i {
        color: #4CAF50;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .end-marker i {
        color: #f44336;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .marker-popup {
        padding: 5px;
        font-family: Arial, sans-serif;
    }

    .leaflet-div-icon {
        background: transparent;
        border: none;
    }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>

<h1>All Routes</h1>
<label for="username">Username:</label>
<select id="username" name="username" required>
  <option value="">Select a user</option>
</select>
<button id="deleteSelected" style="display:none;">Delete Selected</button>
<table id="routesTable">
  <thead>
  <tr>
    <th><input type="checkbox" id="selectAll"></th>
    <th>ID</th>
    <th>End Location</th>
    <th>End Location Pincode</th>
    <th>Mode of Transport</th>
    <th>Username</th>
    <th>Coordinates</th>
    <th>Actions</th>
  </tr>
  </thead>
  <tbody>
  <!-- Rows will be dynamically added here -->
  </tbody>
</table>
<h1>Route Management</h1>

<div id="successMessage"></div>
<div id="errorMessage"></div>

<form id="routeForm">
  <h2>Create a New Route</h2>

  <label for="endLocation">End Location:</label>
  <input type="text" id="endLocation" name="endLocation" required>

  <label for="pincode">End Location Pincode:</label>
  <input type="text" id="pincode" name="pincode" required>

  <label for="modeOfTransport">Mode of Transport:</label>
  <input type="text" id="modeOfTransport" name="modeOfTransport" required>



  <button type="submit">Create Route</button>
</form>

<div id="map">
    <div id="map-loading" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 10px; border-radius: 5px; z-index: 1000;">
        Loading route...
    </div>
</div>

<script>
  document.addEventListener("DOMContentLoaded", function() {
      // Initialize the map globally right away
      const map = L.map('map').setView([20.5937, 78.9629], 5); // Default center of India
      
      // Add the tile layer
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19,
          attribution: 'Â© OpenStreetMap contributors'
      }).addTo(map);

      // Create layer groups for markers and routes
      const markersLayer = L.layerGroup().addTo(map);
      const routeLayer = L.layerGroup().addTo(map);

      const routeForm = document.getElementById('routeForm');
      const routesTable = document.getElementById('routesTable');
      const deleteSelectedBtn = document.getElementById('deleteSelected');
      const selectAllCheckbox = document.getElementById('selectAll');
      const usernameDropdown = document.getElementById('username');

      function showMessage(message, isError = false) {
          const messageElement = isError ? document.getElementById('errorMessage') : document.getElementById('successMessage');
          messageElement.textContent = message;
          setTimeout(() => {
              messageElement.textContent = '';
          }, 5000);
      }

      function fetchUsernames() {
    fetch('/route-management/users')
        .then(response => {
            if (!response.ok) {
                return response.text().then(text => {
                    throw new Error(`HTTP error! status: ${response.status}, body: ${text}`);
                });
            }
            return response.json();
        })
        .then(data => {
            if (data.length === 0) {
                showMessage('No users found.', true);
                return;
            }
            const userOptions = data.map(username => `<option value="${username}">${username}</option>`).join('');
            usernameDropdown.innerHTML = '<option value="">Select a user</option>' + userOptions;
        })
        .catch(error => {
            console.error('Error fetching usernames:', error);
            showMessage('Error fetching usernames: ' + error.message, true);
        });
}

      async function fetchUserHomeAddress(username) {
        const response = await fetch(`/user-management/home-address?username=${encodeURIComponent(username)}`);
        if (!response.ok) {
          throw new Error('Failed to fetch home address');
        }
        return response.json();
      }

      async function fetchRoutes(username = '') {
        try {
            // Clear existing layers
            markersLayer.clearLayers();
            routeLayer.clearLayers();

            let url = '/route-management/routes';
            if (username) {
                url += `?username=${encodeURIComponent(username)}`;
            }

            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();

            const routesTableBody = routesTable.querySelector('tbody');
            routesTableBody.innerHTML = '';

            if (data.length === 0) {
                showMessage('No routes found for the selected user.', true);
                return;
            }

            // First, get the user's home address (start coordinates) once
            let startCoords = null;
            if (data[0].username) {
                try {
                    const userResponse = await fetch(`/user-management/home-address?username=${encodeURIComponent(data[0].username)}`);
                    if (!userResponse.ok) {
                        throw new Error('Failed to fetch home address');
                    }
                    
                    const userData = await userResponse.json();
                    if (userData && userData.homeAddress && userData.pincode) {
                        const fullAddress = `${userData.homeAddress} ${userData.pincode}`;
                        startCoords = await geocodeAddress(fullAddress);
                    }
                } catch (error) {
                    console.error('Error fetching start coordinates:', error);
                    return;
                }
            }

            // Add start marker only once
            if (startCoords) {
                L.marker([startCoords.lat, startCoords.lng], {
                    icon: L.divIcon({
                        className: 'custom-marker start-marker',
                        html: '<i class="fa-solid fa-location-dot fa-2x"></i>',
                        iconSize: [30, 30],
                        iconAnchor: [15, 30],
                        popupAnchor: [0, -30]
                    })
                })
                .bindPopup(`<div class="marker-popup">
                    <strong>Home Location</strong><br>
                    ${data[0].username}'s home
                </div>`)
                .addTo(markersLayer);
            }

            // Process each route
            for (const [index, route] of data.entries()) {
                let endCoords = null;
                
                try {
                    endCoords = await geocodeAddress(route.endLocation + ' ' + route.pincode);
                } catch (error) {
                    console.error('Error fetching end coordinates:', error);
                    continue;
                }

                if (startCoords && endCoords) {
                    // Add end marker
                    L.marker([endCoords.lat, endCoords.lng], {
                        icon: L.divIcon({
                            className: 'custom-marker end-marker',
                            html: '<i class="fa-solid fa-location-dot fa-2x"></i>',
                            iconSize: [30, 30],
                            iconAnchor: [15, 30],
                            popupAnchor: [0, -30]
                        })
                    })
                    .bindPopup(`<div class="marker-popup">
                        <strong>Destination ${index + 1}</strong><br>
                        ${route.endLocation}
                    </div>`)
                    .addTo(markersLayer);

                    // Fetch and display route
                    try {
                        const routeResponse = await fetch(
                            `https://router.project-osrm.org/route/v1/driving/${startCoords.lng},${startCoords.lat};${endCoords.lng},${endCoords.lat}?overview=full&geometries=geojson`
                        );

                        if (!routeResponse.ok) {
                            throw new Error('Failed to fetch route');
                        }

                        const routeData = await routeResponse.json();

                        if (routeData.routes && routeData.routes.length > 0) {
                            // Generate a unique color for this route
                            const hue = (index * 137.508) % 360; // Golden angle for color distribution
                            const routeColor = `hsl(${hue}, 70%, 50%)`;

                            // Add the route with enhanced styling
                            const routeLine = L.geoJSON(routeData.routes[0].geometry, {
                                style: {
                                    color: routeColor,
                                    weight: 5,
                                    opacity: 0.8,
                                    lineCap: 'round',
                                    lineJoin: 'round',
                                    dashArray: null
                                }
                            }).addTo(routeLayer);

                            // Add hover effects
                            routeLine.on('mouseover', function() {
                                this.setStyle({
                                    weight: 8,
                                    opacity: 1
                                });
                            }).on('mouseout', function() {
                                this.setStyle({
                                    weight: 5,
                                    opacity: 0.8
                                });
                            });

                            // Add route popup
                            routeLine.bindPopup(`
                                <div class="route-popup">
                                    <strong>Route ${index + 1}</strong><br>
                                    To: ${route.endLocation}<br>
                                    Mode: ${route.modeOfTransport}<br>
                                    Distance: ${(routeData.routes[0].distance / 1000).toFixed(2)} km
                                </div>
                            `);
                        }
                    } catch (error) {
                        console.error('Error fetching route:', error);
                    }
                }

                // Add table row
                const row = document.createElement('tr');
                row.dataset.id = route.id;
                row.innerHTML = `
                    <td><input type="checkbox" class="route-checkbox"></td>
                    <td>${route.id}</td>
                    <td>${route.endLocation}</td>
                    <td>${route.pincode}</td>
                    <td>${route.modeOfTransport}</td>
                    <td>${route.username || 'N/A'}</td>
                    <td>
                        <strong>Start:</strong> ${startCoords ? `${startCoords.lat.toFixed(6)}, ${startCoords.lng.toFixed(6)}` : 'N/A'}<br>
                        <strong>End:</strong> ${endCoords ? `${endCoords.lat.toFixed(6)}, ${endCoords.lng.toFixed(6)}` : 'N/A'}
                    </td>
                    <td>
                        <button class="edit-btn">Edit</button>
                        <button class="save-btn" style="display:none;">Save</button>
                        <button class="cancel-btn" style="display:none;">Cancel</button>
                    </td>
                `;
                routesTableBody.appendChild(row);
            }

            // Fit the map bounds to show all routes
            if (routeLayer.getLayers().length > 0) {
                const bounds = L.featureGroup([markersLayer, routeLayer]).getBounds();
                map.fitBounds(bounds, { padding: [50, 50] });
            }

        } catch (error) {
            console.error('Error:', error);
            showMessage('Error fetching routes: ' + error.message, true);
        }
      }

      function updateDeleteSelectedButton() {
          const checkedBoxes = document.querySelectorAll('.route-checkbox:checked');
          deleteSelectedBtn.style.display = checkedBoxes.length > 0 ? 'inline-block' : 'none';
      }

      // Fetch usernames and routes when the page loads
      fetchUsernames();
      fetchRoutes();

      routeForm.addEventListener('submit', function(e) {
    e.preventDefault();
    const formData = new FormData(routeForm);
    const routeData = Object.fromEntries(formData.entries());

    // Add the selected username to the routeData
    routeData.username = usernameDropdown.value; // Get the selected username

    fetch('/route-management/routes', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(routeData),
    })
    .then(response => response.json())
    .then(data => {
        showMessage('Route created successfully!');
        routeForm.reset();
        fetchRoutes(); // Refresh the routes table
    })
    .catch(error => {
        console.error('Error:', error);
        showMessage('Error creating route.', true);
    });
});



      routesTable.addEventListener('click', function(e) {
          if (e.target.classList.contains('edit-btn')) {
              const row = e.target.closest('tr');
              row.querySelectorAll('td:not(:last-child):not(:first-child)').forEach(cell => {
                  const value = cell.textContent;
                  cell.innerHTML = `<input type="text" value="${value}">`;
              });
              row.querySelector('.edit-btn').style.display = 'none';
              row.querySelector('.save-btn').style.display = 'inline-block';
              row.querySelector('.cancel-btn').style.display = 'inline-block';
          } else if (e.target.classList.contains('save-btn')) {
              const row = e.target.closest('tr');
              const id = row.dataset.id;
              const updatedData = {
                  id: id,
                  endLocation: row.cells[2].querySelector('input').value,
                  pincode: row.cells[3].querySelector('input').value,
                  modeOfTransport: row.cells[4].querySelector('input').value,
                  username: row.cells[5].querySelector('input').value
              };

              fetch(`/route-management/routes/${id}`, {
                  method: 'PUT',
                  headers: {
                      'Content-Type': 'application/json',
                  },
                  body: JSON.stringify(updatedData),
              })
              .then(response => response.json())
              .then(data => {
                  showMessage('Route updated successfully!');
                  fetchRoutes();
              })
              .catch(error => {
                  console.error('Error:', error);
                  showMessage('Error updating route.', true);
              });
          } else if (e.target.classList.contains('cancel-btn')) {
              fetchRoutes();
          }
      });

      deleteSelectedBtn.addEventListener('click', function() {
    const selectedRoutes = Array.from(document.querySelectorAll('.route-checkbox:checked'))
        .map(checkbox => checkbox.closest('tr').dataset.id);

    if (selectedRoutes.length === 0) return;

    // Confirm deletion
    const confirmation = confirm(`Are you sure you want to delete the selected routes? (${selectedRoutes.length} selected)`);
    if (!confirmation) return; // If not confirmed, exit

    fetch('/route-management/routes', {
        method: 'DELETE',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(selectedRoutes),
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.text(); // Change to text() to handle empty response
    })
    .then(data => {
        showMessage('Selected routes deleted successfully!'); // Success message
        fetchRoutes(); // Refresh routes
    })
    .catch(error => {
        console.error('Error:', error);
        showMessage('Error deleting routes: ' + error.message, true); // Show error message
    });
});



      selectAllCheckbox.addEventListener('change', function() {
          const checkboxes = document.querySelectorAll('.route-checkbox');
          checkboxes.forEach(checkbox => checkbox.checked = this.checked);
          updateDeleteSelectedButton();
      });

      routesTable.addEventListener('change', function(e) {
          if (e.target.classList.contains('route-checkbox')) {
              updateDeleteSelectedButton();
          }
      });

      // Add event listener for username dropdown
      usernameDropdown.addEventListener('change', async function(e) {
          if (e.target.value) {
              try {
                  const userData = await fetchUserHomeAddress(e.target.value);
                  if (userData && userData.homeAddress) {
                      const startCoords = await geocodeAddress(userData.homeAddress + ' ' + userData.pincode);
                      if (startCoords) {
                          window.startCoords = startCoords; // Store for later use
                      }
                  }
              } catch (error) {
                  console.error('Error fetching user home address:', error);
              }
          }
          fetchRoutes(e.target.value);
      });

      async function geocodeAddress(address) {
        console.log('Geocoding address:', address);
        const apiKey = '9289340160b7436ba65e6add726263b7';
        const encodedAddress = encodeURIComponent(address);
        const url = `https://api.opencagedata.com/geocode/v1/json?q=${encodedAddress}&key=${apiKey}`;

        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error('Geocoding request failed');
            }
            const data = await response.json();
            if (data.results && data.results.length > 0) {
                console.log('Geocoding result:', data.results[0].geometry);
                return data.results[0].geometry;
            }
            throw new Error('No results found for address');
        } catch (error) {
            console.error('Geocoding error:', error);
            return null;
        }
      }

      // Add this after defining geocodeAddress function
      async function testGeocoding() {
          const testAddress = "Mumbai 400001";
          const result = await geocodeAddress(testAddress);
          console.log('Test geocoding result:', result);
      }
      // Call it once to verify
      testGeocoding();

      async function displayRoute(startCoords, endCoords) {
          const loadingElement = document.getElementById('map-loading');
          loadingElement.style.display = 'block';
          
          try {
              if (!startCoords || !endCoords) {
                  console.error('Invalid coordinates:', { startCoords, endCoords });
                  return;
              }

              console.log('Displaying route with coordinates:', { startCoords, endCoords });

              // Clear existing markers and route
              markersLayer.clearLayers();
              routeLayer.clearLayers();

              // Add markers
              L.marker([startCoords.lat, startCoords.lng])
                  .bindPopup('Start')
                  .addTo(markersLayer);
              L.marker([endCoords.lat, endCoords.lng])
                  .bindPopup('End')
                  .addTo(markersLayer);

              // Use OSRM API to get the route
              const response = await fetch(
                  `https://router.project-osrm.org/route/v1/driving/${startCoords.lng},${startCoords.lat};${endCoords.lng},${endCoords.lat}?overview=full&geometries=geojson`
              );
              
              if (!response.ok) {
                  throw new Error('Failed to fetch route');
              }

              const data = await response.json();

              if (data.routes && data.routes.length > 0) {
                  // Add the route to the map
                  L.geoJSON(data.routes[0].geometry, {
                      style: {
                          color: '#0000FF',
                          weight: 3,
                          opacity: 0.7
                      }
                  }).addTo(routeLayer);

                  // Fit bounds to show the entire route
                  const bounds = L.latLngBounds([
                      [startCoords.lat, startCoords.lng],
                      [endCoords.lat, endCoords.lng]
                  ]);
                  map.fitBounds(bounds, { padding: [50, 50] });
              } else {
                  console.error('No route found in response');
              }
          } catch (error) {
              console.error('Error fetching route:', error);
          } finally {
              loadingElement.style.display = 'none';
          }
      }
  });
</script>
</body>
</html>