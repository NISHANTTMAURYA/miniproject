<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Route Management</title>
  <style>
    #map {
        height: 400px;
        width: 100%;
        margin: 20px 0;
        border: 1px solid #ccc;
        border-radius: 4px;
    }
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f0f0f0;
    }
    h1, h2 {
        color: #333;
    }
    form {
        background-color: #fff;
        padding: 20px;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
    }
    label {
        display: block;
        margin-bottom: 5px;
    }
    input, select {
        width: 100%;
        padding: 8px;
        margin-bottom: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        box-sizing: border-box;
    }
    button {
        background-color: #4CAF50;
        color: white;
        padding: 10px 15px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }
    button:hover {
        background-color: #45a049;
    }
    table {
        width: 100%;
        border-collapse: collapse;
        background-color: #fff;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    th, td {
        text-align: left;
        padding: 12px;
        border-bottom: 1px solid #ddd;
    }
    th {
        background-color: #f2f2f2;
        font-weight: bold;
    }
    .edit-btn, .save-btn, .cancel-btn {
        padding: 5px 10px;
        margin-right: 5px;
    }
    .edit-btn {
        background-color: #008CBA;
    }
    .save-btn {
        background-color: #4CAF50;
    }
    .cancel-btn {
        background-color: #f44336;
    }
    #successMessage {
        color: green;
        margin-bottom: 10px;
    }
    #errorMessage {
        color: red;
        margin-bottom: 10px;
    }
    #map {
        height: 400px;
        width: 100%;
        margin: 20px 0;
        border: 1px solid #ccc;
        border-radius: 4px;
    }
    .custom-marker {
        background: none;
        border: none;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .start-marker {
        color: #4CAF50;
    }

    .end-marker {
        color: #f44336;
    }

    .marker-popup, .route-popup {
        padding: 5px;
        font-family: Arial, sans-serif;
    }

    .leaflet-popup-content-wrapper {
        border-radius: 8px;
        box-shadow: 0 3px 14px rgba(0,0,0,0.4);
    }

    /* Add Font Awesome for markers */
    @import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css');

    .fa-location-dot {
        font-size: 24px;
        filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.5));
    }

    .start-marker i {
        color: #4CAF50;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .end-marker i {
        color: #f44336;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .marker-popup {
        padding: 5px;
        font-family: Arial, sans-serif;
    }

    .leaflet-div-icon {
        background: transparent;
        border: none;
    }

    .loading-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }

    .loading-spinner {
        width: 50px;
        height: 50px;
        border: 5px solid #f3f3f3;
        border-top: 5px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .loading-text {
        margin-top: 10px;
        color: #333;
        font-weight: bold;
    }

    .route-popup {
        padding: 10px;
        max-width: 250px;
    }

    .route-popup strong {
        display: block;
        margin-bottom: 5px;
        color: #333;
    }

    .custom-marker.start-marker i {
        color: #4CAF50;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        font-size: 24px;
    }
  </style>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="loading-container" id="loadingIndicator">
        <div style="text-align: center;">
            <div class="loading-spinner"></div>
            <div class="loading-text">Loading routes...</div>
        </div>
    </div>

<h1>All Routes</h1>
<label for="username">Username:</label>
<select id="username" name="username" required>
  <option value="">Select a user</option>
</select>
<button id="deleteSelected" style="display:none;">Delete Selected</button>
<table id="routesTable">
  <thead>
  <tr>
    <th><input type="checkbox" id="selectAll"></th>
    <th>ID</th>
    <th>End Location</th>
    <th>End Location Pincode</th>
    <th>Mode of Transport</th>
    <th>Username</th>
    <th>Coordinates</th>
    <th>Duration</th>
    <th>Actions</th>
  </tr>
  </thead>
  <tbody>
  <!-- Rows will be dynamically added here -->
  </tbody>
</table>
<div id="map"></div>
    <div id="map-loading" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 10px; border-radius: 5px; z-index: 1000;">
        Loading route...
    </div>
</div>
<h1>Route Management</h1>

<div id="successMessage"></div>
<div id="errorMessage"></div>

<form id="routeForm">
  <h2>Create a New Route</h2>

  <label for="endLocation">End Location:</label>
  <input type="text" id="endLocation" name="endLocation" required>

  <label for="pincode">End Location Pincode:</label>
  <input type="text" id="pincode" name="pincode" required>

  <label for="modeOfTransport">Mode of Transport:</label>
  <input type="text" id="modeOfTransport" name="modeOfTransport" required>



  <button type="submit">Create Route</button>
</form>



<script>
  document.addEventListener("DOMContentLoaded", function() {
      // Initialize the map globally right away
      const map = L.map('map').setView([20.5937, 78.9629], 5); // Default center of India
      
      // Add the tile layer
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19,
          attribution: 'Â© OpenStreetMap contributors'
      }).addTo(map);

      // Create layer groups for markers and routes
      const markersLayer = L.layerGroup().addTo(map);
      const routeLayer = L.layerGroup().addTo(map);

      const routeForm = document.getElementById('routeForm');
      const routesTable = document.getElementById('routesTable');
      const deleteSelectedBtn = document.getElementById('deleteSelected');
      const selectAllCheckbox = document.getElementById('selectAll');
      const usernameDropdown = document.getElementById('username');

      function showMessage(message, isError = false) {
          const messageElement = isError ? document.getElementById('errorMessage') : document.getElementById('successMessage');
          messageElement.textContent = message;
          setTimeout(() => {
              messageElement.textContent = '';
          }, 5000);
      }

      function fetchUsernames() {
    fetch('/route-management/users')
        .then(response => {
            if (!response.ok) {
                return response.text().then(text => {
                    throw new Error(`HTTP error! status: ${response.status}, body: ${text}`);
                });
            }
            return response.json();
        })
        .then(data => {
            if (data.length === 0) {
                showMessage('No users found.', true);
                return;
            }
            const userOptions = data.map(username => `<option value="${username}">${username}</option>`).join('');
            usernameDropdown.innerHTML = '<option value="">Select a user</option>' + userOptions;
        })
        .catch(error => {
            console.error('Error fetching usernames:', error);
            showMessage('Error fetching usernames: ' + error.message, true);
        });
}

      async function fetchUserHomeAddress(username) {
        const response = await fetch(`/user-management/home-address?username=${encodeURIComponent(username)}`);
        if (!response.ok) {
          throw new Error('Failed to fetch home address');
        }
        return response.json();
      }

      async function fetchRoutes(username = '') {
        const loadingIndicator = document.getElementById('loadingIndicator');
        try {
            loadingIndicator.style.display = 'flex'; // Show loading indicator
            
            // Clear existing layers
            markersLayer.clearLayers();
            routeLayer.clearLayers();
            
            const routesTableBody = routesTable.querySelector('tbody');
            routesTableBody.innerHTML = '';

            let url = '/route-management/routes';
            if (username) {
                url += `?username=${encodeURIComponent(username)}`;
            }

            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();

            if (data.length === 0) {
                showMessage('No routes found for the selected user.', true);
                return;
            }

            // Get all unique routes
            const uniqueRoutes = [...new Map(data.map(route => [route.id, route])).values()];
            
            // Process all routes in parallel
            const routePromises = uniqueRoutes.map(async route => {
                const endCoords = await geocodeAddress(route.endLocation + ' ' + route.pincode);
                if (!startCoords || !endCoords) return null;

                // Get traffic data for all modes in parallel
                const trafficData = await getTrafficData(startCoords, endCoords);
                
                return {
                    route,
                    endCoords,
                    trafficData
                };
            });

            // Wait for all routes to be processed
            const processedRoutes = await Promise.all(routePromises);
            
            // Add markers and create table rows
            processedRoutes.filter(Boolean).forEach(({ route, endCoords, trafficData }) => {
                // Add markers
                addMarkers(endCoords, route.endLocation);
                
                // Create and add table row
                const row = createTableRow(route, startCoords, endCoords, trafficData);
                routesTableBody.appendChild(row);
                
                // Display route on map
                displayRouteWithColor(startCoords, endCoords, trafficData.duration, route.id);
            });

            // Sort routes and fit map bounds
            sortRoutesByDuration();
            fitMapBounds();

        } catch (error) {
            console.error('Error:', error);
            showMessage('Error fetching routes: ' + error.message, true);
        } finally {
            loadingIndicator.style.display = 'none'; // Hide loading indicator
        }
      }

      function addMarkers(coords, location) {
          L.marker([coords.lat, coords.lng], {
              icon: L.divIcon({
                  className: 'custom-marker end-marker',
                  html: '<i class="fa-solid fa-location-dot fa-2x"></i>',
                  iconSize: [30, 30],
                  iconAnchor: [15, 30],
                  popupAnchor: [0, -30]
              })
          })
          .bindPopup(`<div class="marker-popup"><strong>Destination</strong><br>${location}</div>`)
          .addTo(markersLayer);
      }

      function createTableRow(route, startCoords, endCoords, trafficData) {
          const row = document.createElement('tr');
          row.dataset.id = route.id;
          row.dataset.duration = trafficData.duration;
          
          row.innerHTML = `
              <td><input type="checkbox" class="route-checkbox"></td>
              <td>${route.id}</td>
              <td>${route.endLocation}</td>
              <td>${route.pincode}</td>
              <td>${route.modeOfTransport}</td>
              <td>${route.username || 'N/A'}</td>
              <td>
                  <strong>Start:</strong> ${startCoords ? `${startCoords.lat.toFixed(6)}, ${startCoords.lng.toFixed(6)}` : 'N/A'}<br>
                  <strong>End:</strong> ${endCoords ? `${endCoords.lat.toFixed(6)}, ${endCoords.lng.toFixed(6)}` : 'N/A'}
              </td>
              <td>${formatDuration(trafficData.duration)}<br><small>(via ${trafficData.mode})</small></td>
              <td>
                  <button class="edit-btn">Edit</button>
                  <button class="save-btn" style="display:none;">Save</button>
                  <button class="cancel-btn" style="display:none;">Cancel</button>
              </td>
          `;
          return row;
      }

      function fitMapBounds() {
          if (routeLayer.getLayers().length > 0) {
              const bounds = L.featureGroup([markersLayer, routeLayer]).getBounds();
              map.fitBounds(bounds, { padding: [50, 50] });
          }
      }

      function updateDeleteSelectedButton() {
          const checkedBoxes = document.querySelectorAll('.route-checkbox:checked');
          deleteSelectedBtn.style.display = checkedBoxes.length > 0 ? 'inline-block' : 'none';
      }

      // Fetch usernames and routes when the page loads
      fetchUsernames();
      fetchRoutes();

      routeForm.addEventListener('submit', function(e) {
    e.preventDefault();
    const formData = new FormData(routeForm);
    const routeData = Object.fromEntries(formData.entries());

    // Add the selected username to the routeData
    routeData.username = usernameDropdown.value; // Get the selected username

    fetch('/route-management/routes', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(routeData),
    })
    .then(response => response.json())
    .then(data => {
        showMessage('Route created successfully!');
        routeForm.reset();
        fetchRoutes(); // Refresh the routes table
    })
    .catch(error => {
        console.error('Error:', error);
        showMessage('Error creating route.', true);
    });
});



      routesTable.addEventListener('click', function(e) {
          if (e.target.classList.contains('edit-btn')) {
              const row = e.target.closest('tr');
              row.querySelectorAll('td:not(:last-child):not(:first-child)').forEach(cell => {
                  const value = cell.textContent;
                  cell.innerHTML = `<input type="text" value="${value}">`;
              });
              row.querySelector('.edit-btn').style.display = 'none';
              row.querySelector('.save-btn').style.display = 'inline-block';
              row.querySelector('.cancel-btn').style.display = 'inline-block';
          } else if (e.target.classList.contains('save-btn')) {
              const row = e.target.closest('tr');
              const id = row.dataset.id;
              const updatedData = {
                  id: id,
                  endLocation: row.cells[2].querySelector('input').value,
                  pincode: row.cells[3].querySelector('input').value,
                  modeOfTransport: row.cells[4].querySelector('input').value,
                  username: row.cells[5].querySelector('input').value
              };

              fetch(`/route-management/routes/${id}`, {
                  method: 'PUT',
                  headers: {
                      'Content-Type': 'application/json',
                  },
                  body: JSON.stringify(updatedData),
              })
              .then(response => response.json())
              .then(data => {
                  showMessage('Route updated successfully!');
                  fetchRoutes();
              })
              .catch(error => {
                  console.error('Error:', error);
                  showMessage('Error updating route.', true);
              });
          } else if (e.target.classList.contains('cancel-btn')) {
              fetchRoutes();
          }
      });

      deleteSelectedBtn.addEventListener('click', function() {
    const selectedRoutes = Array.from(document.querySelectorAll('.route-checkbox:checked'))
        .map(checkbox => checkbox.closest('tr').dataset.id);

    if (selectedRoutes.length === 0) return;

    // Confirm deletion
    const confirmation = confirm(`Are you sure you want to delete the selected routes? (${selectedRoutes.length} selected)`);
    if (!confirmation) return; // If not confirmed, exit

    fetch('/route-management/routes', {
        method: 'DELETE',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(selectedRoutes),
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.text(); // Change to text() to handle empty response
    })
    .then(data => {
        showMessage('Selected routes deleted successfully!'); // Success message
        fetchRoutes(); // Refresh routes
    })
    .catch(error => {
        console.error('Error:', error);
        showMessage('Error deleting routes: ' + error.message, true); // Show error message
    });
});



      selectAllCheckbox.addEventListener('change', function() {
          const checkboxes = document.querySelectorAll('.route-checkbox');
          checkboxes.forEach(checkbox => checkbox.checked = this.checked);
          updateDeleteSelectedButton();
      });

      routesTable.addEventListener('change', function(e) {
          if (e.target.classList.contains('route-checkbox')) {
              updateDeleteSelectedButton();
          }
      });

      // Add event listener for username dropdown
      usernameDropdown.addEventListener('change', async function(e) {
          if (e.target.value) {
              try {
                  const userData = await fetchUserHomeAddress(e.target.value);
                  if (userData && userData.homeAddress) {
                      const startCoords = await geocodeAddress(userData.homeAddress + ' ' + userData.pincode);
                      if (startCoords) {
                          window.startCoords = startCoords; // Store for later use
                      }
                  }
              } catch (error) {
                  console.error('Error fetching user home address:', error);
              }
          }
          fetchRoutes(e.target.value);
      });

      async function geocodeAddress(address) {
        console.log('Geocoding address:', address);
        const apiKey = '9289340160b7436ba65e6add726263b7';
        const encodedAddress = encodeURIComponent(address);
        const url = `https://api.opencagedata.com/geocode/v1/json?q=${encodedAddress}&key=${apiKey}`;

        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error('Geocoding request failed');
            }
            const data = await response.json();
            if (data.results && data.results.length > 0) {
                console.log('Geocoding result:', data.results[0].geometry);
                return data.results[0].geometry;
            }
            throw new Error('No results found for address');
        } catch (error) {
            console.error('Geocoding error:', error);
            return null;
        }
      }

      // Add this after defining geocodeAddress function
      async function testGeocoding() {
          const testAddress = "Mumbai 400001";
          const result = await geocodeAddress(testAddress);
          console.log('Test geocoding result:', result);
      }
      // Call it once to verify
      testGeocoding();

      async function displayRoute(startCoords, endCoords) {
          const loadingElement = document.getElementById('map-loading');
          loadingElement.style.display = 'block';
          
          try {
              if (!startCoords || !endCoords) {
                  console.error('Invalid coordinates:', { startCoords, endCoords });
                  return;
              }

              console.log('Displaying route with coordinates:', { startCoords, endCoords });

              // Clear existing markers and route
              markersLayer.clearLayers();
              routeLayer.clearLayers();

              // Add markers
              L.marker([startCoords.lat, startCoords.lng])
                  .bindPopup('Start')
                  .addTo(markersLayer);
              L.marker([endCoords.lat, endCoords.lng])
                  .bindPopup('End')
                  .addTo(markersLayer);

              // Use OSRM API to get the route
              const response = await fetch(
                  `https://router.project-osrm.org/route/v1/driving/${startCoords.lng},${startCoords.lat};${endCoords.lng},${endCoords.lat}?overview=full&geometries=geojson`
              );
              
              if (!response.ok) {
                  throw new Error('Failed to fetch route');
              }

              const data = await response.json();

              if (data.routes && data.routes.length > 0) {
                  // Add the route to the map
                  L.geoJSON(data.routes[0].geometry, {
                      style: {
                          color: '#0000FF',
                          weight: 3,
                          opacity: 0.7
                      }
                  }).addTo(routeLayer);

                  // Fit bounds to show the entire route
                  const bounds = L.latLngBounds([
                      [startCoords.lat, startCoords.lng],
                      [endCoords.lat, endCoords.lng]
                  ]);
                  map.fitBounds(bounds, { padding: [50, 50] });
              } else {
                  console.error('No route found in response');
              }
          } catch (error) {
              console.error('Error fetching route:', error);
          } finally {
              loadingElement.style.display = 'none';
          }
      }

      function sortRoutesByDuration() {
          const tbody = document.querySelector('#routesTable tbody');
          const rows = Array.from(tbody.querySelectorAll('tr'));
          
          rows.sort((a, b) => {
              const durationA = parseFloat(a.getAttribute('data-duration') || '0');
              const durationB = parseFloat(b.getAttribute('data-duration') || '0');
              return durationA - durationB;
          });
          
          rows.forEach(row => tbody.appendChild(row));
      }

      async function updateRouteWithTrafficData(startCoords, endCoords, row) {
          try {
              const modes = ['driving-car', 'foot-walking', 'cycling-regular'];
              let bestDuration = Infinity;
              let routeData = {};

              for (const mode of modes) {
                  const response = await fetch(`/travel-time?startLat=${startCoords.lat}&startLon=${startCoords.lng}&endLat=${endCoords.lat}&endLon=${endCoords.lng}&mode=${mode}`);
                  const data = JSON.parse(await response.text());
                  
                  if (data.duration < bestDuration) {
                      bestDuration = data.duration;
                      routeData = data;
                  }
              }

              // Update row with traffic information
              const durationCell = document.createElement('td');
              durationCell.innerHTML = `${routeData.duration.toFixed(2)} mins`;
              row.appendChild(durationCell);
              
              // Store duration for sorting
              row.setAttribute('data-duration', routeData.duration);
              
              // Update route color based on duration
              const routeLine = routeLayer.getLayers().find(layer => 
                  layer.options.routeId === row.dataset.id
              );
              
              if (routeLine) {
                  const color = getDurationColor(routeData.duration);
                  routeLine.setStyle({ color: color });
              }
          } catch (error) {
              console.error('Error updating traffic data:', error);
          }
      }

      function getDurationColor(duration) {
          if (duration <= 10) return '#00ff00'; // Green for quick routes
          if (duration <= 20) return '#ffff00'; // Yellow for medium duration
          return '#ff0000'; // Red for longer duration
      }

      async function getTrafficData(startCoords, endCoords) {
          try {
              const modes = ['driving-car', 'foot-walking', 'cycling-regular'];
              const promises = modes.map(mode => 
                  fetch(`/travel-time?startLat=${startCoords.lat}&startLon=${startCoords.lng}&endLat=${endCoords.lat}&endLon=${endCoords.lng}&mode=${mode}`)
                  .then(res => res.json())
              );

              const results = await Promise.all(promises);
              let bestDuration = Infinity;
              let bestMode = null;

              results.forEach((data, index) => {
                  if (data.duration < bestDuration) {
                      bestDuration = data.duration;
                      bestMode = modes[index];
                  }
              });

              return {
                  duration: bestDuration,
                  mode: bestMode
              };
          } catch (error) {
              console.error('Error getting traffic data:', error);
              return {
                  duration: 0,
                  mode: 'Unknown'
              };
          }
      }

      async function displayRouteWithColor(startCoords, endCoords, duration, routeId) {
          try {
              // Add start marker with custom icon
              L.marker([startCoords.lat, startCoords.lng], {
                  icon: L.divIcon({
                      className: 'custom-marker start-marker',
                      html: '<i class="fa-solid fa-location-dot fa-2x"></i>',
                      iconSize: [30, 30],
                      iconAnchor: [15, 30],
                      popupAnchor: [0, -30]
                  })
              })
              .bindPopup(`<div class="marker-popup"><strong>Start Location</strong></div>`)
              .addTo(markersLayer);

              const response = await fetch(
                  `https://router.project-osrm.org/route/v1/driving/${startCoords.lng},${startCoords.lat};${endCoords.lng},${endCoords.lat}?overview=full&geometries=geojson`
              );
              
              if (!response.ok) throw new Error('Failed to fetch route');
              
              const data = await response.json();
              if (!data.routes || !data.routes.length) throw new Error('No route found');

              const color = getDurationColor(duration);
              const routeLine = L.geoJSON(data.routes[0].geometry, {
                  style: {
                      color: color,
                      weight: 5,
                      opacity: 0.8
                  },
                  routeId: routeId
              }).addTo(routeLayer);

              // Add route click handler
              routeLine.on('click', function(e) {
                  const popup = L.popup()
                      .setLatLng(e.latlng)
                      .setContent(`
                          <div class="route-popup">
                              <strong>Route Information</strong><br>
                              Duration: ${formatDuration(duration)}<br>
                              Distance: ${(data.routes[0].distance / 1000).toFixed(2)} km<br>
                              Start: ${startCoords.lat.toFixed(6)}, ${startCoords.lng.toFixed(6)}<br>
                              End: ${endCoords.lat.toFixed(6)}, ${endCoords.lng.toFixed(6)}
                          </div>
                      `)
                      .openOn(map);
              });

              routeLine.on('mouseover', function() {
                  this.setStyle({ weight: 8, opacity: 1 });
              }).on('mouseout', function() {
                  this.setStyle({ weight: 5, opacity: 0.8 });
              });

              return routeLine;
          } catch (error) {
              console.error('Error displaying route:', error);
              return null;
          }
      }

      function sortRoutesByDuration() {
          const tbody = document.querySelector('#routesTable tbody');
          const rows = Array.from(tbody.querySelectorAll('tr'));
          
          rows.sort((a, b) => {
              const durationA = parseFloat(a.dataset.duration || '0');
              const durationB = parseFloat(b.dataset.duration || '0');
              return durationA - durationB;
          });
          
          rows.forEach(row => tbody.appendChild(row));
      }

      function formatDuration(minutes) {
          const hours = Math.floor(minutes / 60);
          const remainingMinutes = Math.round(minutes % 60);
          
          if (hours === 0) {
              return `${remainingMinutes} mins`;
          } else if (remainingMinutes === 0) {
              return `${hours} ${hours === 1 ? 'hour' : 'hours'}`;
          } else {
              return `${hours} ${hours === 1 ? 'hour' : 'hours'} ${remainingMinutes} mins`;
          }
      }
  });
</script>
</body>
</html>